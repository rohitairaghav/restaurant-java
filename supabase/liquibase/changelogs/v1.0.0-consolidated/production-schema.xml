<?xml version="1.0" encoding="UTF-8"?>
<databaseChangeLog
    xmlns="http://www.liquibase.org/xml/ns/dbchangelog"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://www.liquibase.org/xml/ns/dbchangelog
                        http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-4.24.xsd">

    <!--
    PRODUCTION-READY CONSOLIDATED SCHEMA v1.0.0

    This is a clean, consolidated version of all development migrations.
    Use this for fresh production deployments.

    For existing databases that went through incremental development migrations,
    continue using the incremental changesets in v1.0.0/ directory.
    -->

    <changeSet id="prod-1" author="system" context="prod-fresh">
        <preConditions onFail="MARK_RAN">
            <not>
                <tableExists tableName="restaurants"/>
            </not>
        </preConditions>
        <comment>Create core database schema</comment>
        <sql>
            -- Enable necessary extensions
            CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

            -- Create restaurants table
            CREATE TABLE restaurants (
                id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
                name VARCHAR(255) NOT NULL,
                address TEXT,
                phone VARCHAR(50),
                created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
                updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
            );

            -- Create user_profiles table (extends auth.users)
            CREATE TABLE user_profiles (
                id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
                email VARCHAR(255) NOT NULL UNIQUE,
                role VARCHAR(20) NOT NULL CHECK (role IN ('manager', 'staff')),
                restaurant_id UUID REFERENCES restaurants(id) ON DELETE CASCADE,
                created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
                updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
            );

            -- Create suppliers table
            CREATE TABLE suppliers (
                id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
                name VARCHAR(255) NOT NULL,
                contact_person VARCHAR(255),
                phone VARCHAR(50),
                email VARCHAR(255),
                address TEXT,
                restaurant_id UUID REFERENCES restaurants(id) ON DELETE CASCADE,
                created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
                updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
            );

            -- Create inventory_items table
            CREATE TABLE inventory_items (
                id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
                name VARCHAR(255) NOT NULL,
                category VARCHAR(100) NOT NULL,
                unit VARCHAR(50) NOT NULL,
                cost_per_unit DECIMAL(10,2) NOT NULL,
                current_stock DECIMAL(10,2) DEFAULT 0 CHECK (current_stock >= 0),
                min_threshold DECIMAL(10,2) NOT NULL,
                sku VARCHAR(100),
                supplier_id UUID REFERENCES suppliers(id) ON DELETE SET NULL,
                restaurant_id UUID REFERENCES restaurants(id) ON DELETE CASCADE,
                created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
                updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
            );

            -- Create stock_transactions table
            CREATE TABLE stock_transactions (
                id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
                item_id UUID REFERENCES inventory_items(id) ON DELETE CASCADE,
                type VARCHAR(10) NOT NULL CHECK (type IN ('in', 'out')),
                quantity DECIMAL(10,2) NOT NULL,
                cost DECIMAL(10,2),
                reason VARCHAR(50) NOT NULL CHECK (reason IN ('purchase', 'delivery', 'sale', 'waste', 'transfer')),
                sku VARCHAR(100),
                notes TEXT,
                user_id UUID REFERENCES auth.users(id) ON DELETE SET NULL,
                restaurant_id UUID REFERENCES restaurants(id) ON DELETE CASCADE,
                created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
                updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
            );

            -- Create alerts table
            CREATE TABLE alerts (
                id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
                item_id UUID REFERENCES inventory_items(id) ON DELETE CASCADE,
                type VARCHAR(20) NOT NULL CHECK (type IN ('low_stock', 'out_of_stock')),
                message TEXT NOT NULL,
                is_read BOOLEAN DEFAULT FALSE,
                restaurant_id UUID REFERENCES restaurants(id) ON DELETE CASCADE,
                created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
            );

            -- Create audit_logs table for security tracking
            CREATE TABLE audit_logs (
                id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
                user_id UUID REFERENCES auth.users(id) ON DELETE SET NULL,
                action VARCHAR(100) NOT NULL,
                table_name VARCHAR(100) NOT NULL,
                record_id UUID,
                old_values JSONB,
                new_values JSONB,
                ip_address INET,
                user_agent TEXT,
                restaurant_id UUID REFERENCES restaurants(id) ON DELETE CASCADE,
                created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
            );

            -- Create recipes table
            CREATE TABLE recipes (
                id BIGSERIAL PRIMARY KEY,
                name VARCHAR(255) NOT NULL,
                description TEXT,
                status VARCHAR(20) NOT NULL CHECK (status IN ('Active', 'Disabled', 'Removed')),
                quantity DECIMAL(10,2),
                unit VARCHAR(50) CHECK (
                    unit IS NULL OR
                    unit IN (
                        'servings', 'portions', 'pieces', 'kg', 'g',
                        'liters', 'ml', 'cups', 'plates', 'bowls', 'batches'
                    )
                ),
                created_by UUID NOT NULL REFERENCES auth.users(id),
                updated_by UUID NOT NULL REFERENCES auth.users(id),
                created_at BIGINT NOT NULL,
                updated_at BIGINT NOT NULL,
                content JSONB NOT NULL,
                restaurant_id UUID NOT NULL REFERENCES restaurants(id) ON DELETE CASCADE
            );

            -- Create sales table
            CREATE TABLE sales (
                id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
                recipe_id BIGINT NOT NULL REFERENCES recipes(id) ON DELETE CASCADE,
                inventory_updated BOOLEAN NOT NULL DEFAULT FALSE,
                quantity DECIMAL(10,2) NOT NULL,
                receipt_id TEXT,
                restaurant_id UUID NOT NULL REFERENCES restaurants(id) ON DELETE CASCADE,
                created_by UUID NOT NULL REFERENCES auth.users(id),
                updated_by UUID NOT NULL REFERENCES auth.users(id),
                created_at BIGINT NOT NULL,
                updated_at BIGINT NOT NULL
            );
        </sql>
    </changeSet>

    <changeSet id="prod-2" author="system" context="prod-fresh">
        <comment>Create indexes for performance</comment>
        <sql>
            CREATE INDEX idx_user_profiles_restaurant_id ON user_profiles(restaurant_id);
            CREATE INDEX idx_user_profiles_role ON user_profiles(role);
            CREATE INDEX idx_suppliers_restaurant_id ON suppliers(restaurant_id);
            CREATE INDEX idx_inventory_items_restaurant_id ON inventory_items(restaurant_id);
            CREATE INDEX idx_inventory_items_supplier_id ON inventory_items(supplier_id);
            CREATE INDEX idx_inventory_items_category ON inventory_items(category);
            CREATE INDEX idx_stock_transactions_item_id ON stock_transactions(item_id);
            CREATE INDEX idx_stock_transactions_restaurant_id ON stock_transactions(restaurant_id);
            CREATE INDEX idx_stock_transactions_created_at ON stock_transactions(created_at);
            CREATE INDEX idx_stock_transactions_type ON stock_transactions(type);
            CREATE INDEX idx_alerts_restaurant_id ON alerts(restaurant_id);
            CREATE INDEX idx_alerts_is_read ON alerts(is_read);
            CREATE INDEX idx_alerts_type ON alerts(type);
            CREATE INDEX idx_audit_logs_restaurant_id ON audit_logs(restaurant_id);
            CREATE INDEX idx_audit_logs_user_id ON audit_logs(user_id);
            CREATE INDEX idx_audit_logs_table_name ON audit_logs(table_name);
            CREATE INDEX idx_audit_logs_created_at ON audit_logs(created_at);
            CREATE INDEX idx_recipes_restaurant_id ON recipes(restaurant_id);
            CREATE INDEX idx_recipes_status ON recipes(status);
            CREATE INDEX idx_recipes_content_gin ON recipes USING GIN (content);
            CREATE INDEX idx_sales_recipe_id ON sales(recipe_id);
            CREATE INDEX idx_sales_restaurant_id ON sales(restaurant_id);
            CREATE INDEX idx_sales_inventory_updated ON sales(inventory_updated);
            CREATE INDEX idx_sales_created_at ON sales(created_at);
        </sql>
    </changeSet>

    <changeSet id="prod-3" author="system" context="prod-fresh">
        <comment>Create triggers and functions</comment>
        <sql splitStatements="false">
            -- Updated_at trigger function
            CREATE OR REPLACE FUNCTION update_updated_at_column()
            RETURNS TRIGGER AS $$
            BEGIN
                NEW.updated_at = NOW();
                RETURN NEW;
            END;
            $$ LANGUAGE plpgsql;

            -- Create triggers for updated_at
            CREATE TRIGGER update_restaurants_updated_at
                BEFORE UPDATE ON restaurants
                FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

            CREATE TRIGGER update_user_profiles_updated_at
                BEFORE UPDATE ON user_profiles
                FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

            CREATE TRIGGER update_suppliers_updated_at
                BEFORE UPDATE ON suppliers
                FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

            CREATE TRIGGER update_inventory_items_updated_at
                BEFORE UPDATE ON inventory_items
                FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

            CREATE TRIGGER update_stock_transactions_updated_at
                BEFORE UPDATE ON stock_transactions
                FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

            -- Stock update trigger function
            CREATE OR REPLACE FUNCTION update_stock_on_transaction()
            RETURNS TRIGGER AS $$
            BEGIN
                IF NEW.type = 'in' THEN
                    UPDATE inventory_items
                    SET current_stock = current_stock + NEW.quantity
                    WHERE id = NEW.item_id;
                ELSIF NEW.type = 'out' THEN
                    UPDATE inventory_items
                    SET current_stock = current_stock - NEW.quantity
                    WHERE id = NEW.item_id;
                END IF;
                RETURN NEW;
            END;
            $$ LANGUAGE plpgsql;

            CREATE TRIGGER stock_transaction_update
                AFTER INSERT ON stock_transactions
                FOR EACH ROW EXECUTE FUNCTION update_stock_on_transaction();

            -- Alert creation trigger function
            CREATE OR REPLACE FUNCTION check_stock_alert()
            RETURNS TRIGGER AS $$
            DECLARE
                alert_type VARCHAR(20);
                alert_message TEXT;
            BEGIN
                IF NEW.current_stock = 0 THEN
                    alert_type := 'out_of_stock';
                    alert_message := NEW.name || ' is out of stock';
                ELSIF NEW.current_stock <= NEW.min_threshold THEN
                    alert_type := 'low_stock';
                    alert_message := NEW.name || ' is running low';
                ELSE
                    RETURN NEW;
                END IF;

                INSERT INTO alerts (item_id, type, message, restaurant_id)
                VALUES (NEW.id, alert_type, alert_message, NEW.restaurant_id);

                RETURN NEW;
            END;
            $$ LANGUAGE plpgsql;

            CREATE TRIGGER inventory_alert_check
                AFTER INSERT OR UPDATE OF current_stock ON inventory_items
                FOR EACH ROW EXECUTE FUNCTION check_stock_alert();

            -- Audit logging function
            CREATE OR REPLACE FUNCTION log_audit_trail()
            RETURNS TRIGGER AS $$
            BEGIN
                INSERT INTO audit_logs (
                    user_id,
                    action,
                    table_name,
                    record_id,
                    old_values,
                    new_values,
                    restaurant_id
                ) VALUES (
                    auth.uid(),
                    TG_OP,
                    TG_TABLE_NAME,
                    COALESCE(NEW.id, OLD.id),
                    CASE WHEN TG_OP IN ('UPDATE', 'DELETE') THEN to_jsonb(OLD) ELSE NULL END,
                    CASE WHEN TG_OP IN ('INSERT', 'UPDATE') THEN to_jsonb(NEW) ELSE NULL END,
                    COALESCE(NEW.restaurant_id, OLD.restaurant_id)
                );
                RETURN COALESCE(NEW, OLD);
            END;
            $$ LANGUAGE plpgsql SECURITY DEFINER;

            -- Create audit triggers for key tables
            CREATE TRIGGER audit_user_profiles
                AFTER INSERT OR UPDATE OR DELETE ON user_profiles
                FOR EACH ROW EXECUTE FUNCTION log_audit_trail();

            CREATE TRIGGER audit_inventory_items
                AFTER INSERT OR UPDATE OR DELETE ON inventory_items
                FOR EACH ROW EXECUTE FUNCTION log_audit_trail();

            CREATE TRIGGER audit_stock_transactions
                AFTER INSERT OR DELETE ON stock_transactions
                FOR EACH ROW EXECUTE FUNCTION log_audit_trail();
        </sql>
    </changeSet>

    <changeSet id="prod-4" author="system" context="prod-fresh">
        <comment>Enable Row-Level Security and create simple authentication-based policies</comment>
        <sql>
            -- Enable RLS on all tables
            ALTER TABLE restaurants ENABLE ROW LEVEL SECURITY;
            ALTER TABLE user_profiles ENABLE ROW LEVEL SECURITY;
            ALTER TABLE suppliers ENABLE ROW LEVEL SECURITY;
            ALTER TABLE inventory_items ENABLE ROW LEVEL SECURITY;
            ALTER TABLE stock_transactions ENABLE ROW LEVEL SECURITY;
            ALTER TABLE alerts ENABLE ROW LEVEL SECURITY;
            ALTER TABLE audit_logs ENABLE ROW LEVEL SECURITY;
            ALTER TABLE recipes ENABLE ROW LEVEL SECURITY;
            ALTER TABLE sales ENABLE ROW LEVEL SECURITY;

            -- Service role has full access (for backend operations)
            CREATE POLICY "Service role full access" ON user_profiles
                FOR ALL TO service_role
                USING (true)
                WITH CHECK (true);

            CREATE POLICY "Service role full access" ON restaurants
                FOR ALL TO service_role
                USING (true)
                WITH CHECK (true);

            -- Simple authentication-based policies for user_profiles
            -- Authorization is handled by CASL on the server side
            CREATE POLICY "Authenticated users can read user_profiles" ON user_profiles
                FOR SELECT TO authenticated
                USING (true);

            CREATE POLICY "Authenticated users can insert user_profiles" ON user_profiles
                FOR INSERT TO authenticated
                WITH CHECK (true);

            CREATE POLICY "Authenticated users can update user_profiles" ON user_profiles
                FOR UPDATE TO authenticated
                USING (true)
                WITH CHECK (true);

            CREATE POLICY "Authenticated users can delete user_profiles" ON user_profiles
                FOR DELETE TO authenticated
                USING (true);

            -- Restaurant-scoped policies for other tables
            CREATE POLICY "Users access own restaurant suppliers" ON suppliers
                FOR ALL TO authenticated
                USING (
                    restaurant_id IN (
                        SELECT restaurant_id FROM user_profiles WHERE id = auth.uid()
                    )
                );

            CREATE POLICY "Users access own restaurant inventory" ON inventory_items
                FOR ALL TO authenticated
                USING (
                    restaurant_id IN (
                        SELECT restaurant_id FROM user_profiles WHERE id = auth.uid()
                    )
                );

            CREATE POLICY "Users access own restaurant transactions" ON stock_transactions
                FOR ALL TO authenticated
                USING (
                    restaurant_id IN (
                        SELECT restaurant_id FROM user_profiles WHERE id = auth.uid()
                    )
                );

            CREATE POLICY "Users access own restaurant alerts" ON alerts
                FOR ALL TO authenticated
                USING (
                    restaurant_id IN (
                        SELECT restaurant_id FROM user_profiles WHERE id = auth.uid()
                    )
                );

            CREATE POLICY "Users view own restaurant audit logs" ON audit_logs
                FOR SELECT TO authenticated
                USING (
                    restaurant_id IN (
                        SELECT restaurant_id FROM user_profiles WHERE id = auth.uid()
                    )
                );

            CREATE POLICY "Users access own restaurant" ON restaurants
                FOR SELECT TO authenticated
                USING (
                    id IN (
                        SELECT restaurant_id FROM user_profiles WHERE id = auth.uid()
                    )
                );

            CREATE POLICY "Users access own restaurant recipes" ON recipes
                FOR ALL TO authenticated
                USING (
                    restaurant_id IN (
                        SELECT restaurant_id FROM user_profiles WHERE id = auth.uid()
                    )
                );

            CREATE POLICY "Users access own restaurant sales" ON sales
                FOR ALL TO authenticated
                USING (
                    restaurant_id IN (
                        SELECT restaurant_id FROM user_profiles WHERE id = auth.uid()
                    )
                );
        </sql>
    </changeSet>

</databaseChangeLog>
